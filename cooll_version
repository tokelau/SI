#include <stdio.h> // Стандартная библиотека для ввода-вывода
#include <dirent.h> // Библиотека работы с директориями
#include <string.h>
#include <math.h>//для корня

// Можно наделать таких блоков для каждого варианта,
// и потом переключать значения макроса ENCODE_CRUFT

    #define AP_L 224
    #define AP_R 255
    #define CAPS_L 192
    #define CAPS_R 223
    #define AP_JO 184
    #define CAPS_JO 168

/*  Заклинания
    Создаём переменные, необходимые для работы с библиотеками
*/
DIR *dir;
struct dirent *ent;

/*  Функция, которая обрабатывает файл */
void filework (char *filename, int p[33])
{
    int i;
    float y [33]; // массив для каждого текста
    for (i=0; i<=32; i++)
        y[i]=0;
    FILE *qwero1;
    qwero1=fopen("C:\\qwero1.txt", "a");
    FILE *qwero;
    qwero=fopen("C:\\qwero.txt", "w");
    fprintf(qwero, "%s\n", "hello");
    char newfilename[80]; //  это для работы с текстовым файлом
    strcpy(newfilename, "C:\\qwer\\");
    strcat(newfilename, filename); // задаем имя файла, скоторым будем работать
    int c; // В эту переменную будут писаться символы из файла
    FILE *ff; // Это переменная для файла
    if (filename[0] != '.') // Игнорируем файлы, которые начинаются с точки
    {
        ff = fopen (newfilename, "r"); //Открываем файл для чтения
        while (( c = fgetc ( ff )) != EOF)  // Читаем символы по одному
        {
              if (c>=AP_L && c <=AP_R) /* а-я */
        {
            p[32]++;//в общицй счетчик
            c-=AP_L;
            p[c]++;
            y[c]++;
            y[32]++;
            //printf("%d\n",p[c]);
        }
                if (c>=CAPS_L && c<= CAPS_R) /* А-Я */
        {
            y[32]++;
            p[32]++; //в общицй счетчик
            c-=CAPS_L;
            p[c]++;
            y[c]++;
            //printf("%d\n", p[c]);
        }
                if (c==AP_JO || c==CAPS_JO)
                {
                    p[32]++;//в общицй счетчик
                    p[5]++;
                    y[32]++;//в общицй счетчик
                    y[5]++;
            //printf("%d\n", p[c]);
                }

        }
        printf("1\n");
        fclose (ff); // Когда прочитали все символы, закрываем файл
         /*расфасовываем массив, который на один файл*/
     c=y[0];//расфасовать согласно базовым данным
    y[0]=y[14];
    y[14]=y[19];
    y[19]=y[7];
    y[7]=y[16];
    y[16]=y[27];
    y[27]=y[22];
    y[22]=y[9];
    y[9]=y[11];
    y[11]=y[12];
    y[12]=y[4];
    y[4]=y[13];
    y[13]=y[15];
    y[15]=y[31];
    y[31]=y[26];
    y[26]=y[30];
    y[30]=y[20];
    y[20]=y[1];
    y[1]=y[5];
    y[5]=y[18];
    y[18]=y[3];
    y[3]=y[8];
    y[8]=y[2];
    y[2]=c;
        c=y[6];
    y[6]=y[17];
    y[17]=y[28];
    y[28]=y[25];
    y[25]=y[24];
    y[24]=c;
        c=y[21];
    y[21]=y[23];
    y[23]=c;
        for(i=0; i<=32; i++)
        {
            fprintf(qwero1, "%f\n", y[i]);
        }
    /*среднее квадратичное для каждого файла*/
        float  csr=0;
        for (i=0; i<32; i++)
    {
        csr=csr+y[i];
    }
    csr/=(float)32;
    for (i=0; i<=31; i++)
        y[i]=(y[i]-csr)*(y[i]-csr);
    for (i=1; i<=31; i++)
        y[i]=y[i-1]+y[i];
    y[31]/=(float)32;
    fprintf(qwero1,"\n");
    fprintf(qwero1, "\n");
    fprintf(qwero1, "%f\n", sqrt(y[31]));
    fprintf(qwero1,"\n");
    fprintf(qwero1, "\n");

            fclose(qwero1);
    }

    c=p[0];//расфасовать согласно базовым данным
    p[0]=p[14];
    p[14]=p[19];
    p[19]=p[7];
    p[7]=p[16];
    p[16]=p[27];
    p[27]=p[22];
    p[22]=p[9];
    p[9]=p[11];
    p[11]=p[12];
    p[12]=p[4];
    p[4]=p[13];
    p[13]=p[15];
    p[15]=p[31];
    p[31]=p[26];
    p[26]=p[30];
    p[30]=p[20];
    p[20]=p[1];
    p[1]=p[5];
    p[5]=p[18];
    p[18]=p[3];
    p[3]=p[8];
    p[8]=p[2];
    p[2]=c;
        c=p[6];
    p[6]=p[17];
    p[17]=p[28];
    p[28]=p[25];
    p[25]=p[24];
    p[24]=c;
        c=p[21];
    p[21]=p[23];
    p[23]=c;
        for (i=0; i<=32; i++)
    fprintf(qwero, "%d\n", p[i]);
        fclose(qwero);
    c=p[0];
    p[0]=p[2];
    p[2]=p[8];
    p[8]=p[3];
    p[3]=p[18];
    p[18]=p[5];
    p[5]=p[1];
    p[1]=p[20];
    p[20]=p[30];
    p[30]=p[26];
    p[26]=p[31];
    p[31]=p[15];
    p[15]=p[13];
    p[13]=p[4];
    p[4]=p[12];
    p[12]=p[11];
    p[11]=p[9];
    p[9]=p[22];
    p[22]=p[27];
    p[27]=p[16];
    p[16]=p[7];
    p[7]=p[19];
    p[19]=p[14];
    p[14]=c;
        c=p[6];
        p[6]=p[24];
        p[24]=p[25];
        p[25]=p[28];
        p[28]=p[17];
        p[17]=c;
    c=p[21];
    p[21]=p[23];
    p[23]=c;
}

int main()
{
int p[33];

    int i;
    for (i=0; i<=32; i++)
    {
        p[i]=0;
    }
    if ((dir = opendir ("C:\\qwer")) == NULL) // Открываем директорию.
    {
        printf ("Error while opening directory"); //Если директория не нашлась, пишем сообщение об ошибке.
        return 1;
    }
    else //Если всё хорошо, идём дальше
    {
        while ((ent = readdir (dir)) != NULL) //Читаем следующее имя файла в директории. Оно будет равно NULL, если файлы закончиились.
        {
        /*  *ent).d_name или ent -> d_name это функция, которая возвращает строку, в которой записано имя файла.
            Эту строку мы передаём нашей функции, filework
        */
            filework ((*ent).d_name, p);
        }
        closedir (dir); //Когда все файлы обработаны, закрываем директорию.
/*        printf ("Done!\n"); //Пишем что-нибудь на прощание.*/
    }
}
