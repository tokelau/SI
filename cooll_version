
#include <stdio.h> // Стандартная библиотека для ввода-вывода
#include <dirent.h> // Библиотека работы с директориями
#include <string.h>
#include <math.h>//для корня

// Можно наделать таких блоков для каждого варианта,
// и потом переключать значения макроса ENCODE_CRUFT

    #define AP_L 224
    #define AP_R 255
    #define CAPS_L 192
    #define CAPS_R 223
    #define AP_JO 184
    #define CAPS_JO 168

/*  Заклинания
    Создаём переменные, необходимые для работы с библиотеками
*/
float k=0;
float p[33];
DIR *dir;
struct dirent *ent;

/*  Функция, которая обрабатывает файл */
void filework (char *filename, float n)
{
    float m=0;
    float  csr[32];
    int i;

    float y[33]; // массив для каждого текста
    for (i=0; i<=32; i++)
        y[i]=0;
    FILE *qwero1;
    qwero1=fopen("C:\\qwero1.txt", "a");
    //fprintf(qwero1, "132");
    FILE *qwero;
    qwero=fopen("C:\\qwero.txt", "w");
    fprintf(qwero, "%s\n", "hello");
    char newfilename[80]; //  это для работы с текстовым файлом
    strcpy(newfilename, "C:\\qwer\\");
    strcat(newfilename, filename); // задаем имя файла, скоторым будем работать
    int c; // В эту переменную будут писаться символы из файла
    FILE *ff; // Это переменная для файла
    if (filename[0] != '.') // Игнорируем файлы, которые начинаются с точки
    {
        ff = fopen (newfilename, "r"); //Открываем файл для чтения
        while (( c = fgetc ( ff )) != EOF)  // Читаем символы по одному
        {
            if (c>=AP_L && c <=AP_R) /* а-я */
            {
                p[32]++;//в общий счетчик
                c-=AP_L;
                p[c]++;
                }
        if (c>=CAPS_L && c<= CAPS_R) /* А-Я */
        {
            p[32]++; //в общицй счетчик
            c-=CAPS_L;
            p[c]++;
            //printf("%d\n", p[c]);
        }
                if (c==AP_JO || c==CAPS_JO)
                {
                    p[32]++;//в общицй счетчик
                    p[5]++;
            //printf("%d\n", p[c]);
                }
        }
        //printf("File processed!\n");
        k++;
    }
    m=p[0];//расфасовать согласно базовым данным
    p[0]=p[14];
    p[14]=p[19];
    p[19]=p[7];
    p[7]=p[16];
    p[16]=p[27];
    p[27]=p[22];
    p[22]=p[9];
    p[9]=p[11];
    p[11]=p[12];
    p[12]=p[4];
    p[4]=p[13];
    p[13]=p[15];
    p[15]=p[31];
    p[31]=p[26];
    p[26]=p[30];
    p[30]=p[20];
    p[20]=p[1];
    p[1]=p[5];
    p[5]=p[18];
    p[18]=p[3];
    p[3]=p[8];
    p[8]=p[2];
    p[2]=m;
        m=p[6];
    p[6]=p[17];
    p[17]=p[28];
    p[28]=p[25];
    p[25]=p[24];
    p[24]=m;
        m=p[21];
    p[21]=p[23];
    p[23]=m;
for (i=0; i<=32; i++)
{
    //printf("%f\n", p[i]);
}

    /*


    ВТОРОЙ ЗАХОД


    */
    //if (k==n)
    {
       // printf("1\n");
    if (filename[0] != '.') // Игнорируем файлы, которые начинаются с точки
    {
        k++;
        printf("%f\n", k);
            for (i=0; i<=31; i++)
    {
        csr[i]=0;
    }
        for (i=0; i<=32; i++)
        y[i]=0;
        //printf("%f/n", n);
        strcpy(newfilename, "C:\\qwer\\");
        strcat(newfilename, filename);
        //printf("File \"%s\" seems to exist...\n", newfilename);
        ff = fopen (newfilename, "r"); //Открываем файл для чтения
        while (( c = fgetc ( ff )) != EOF)  // Читаем символы по одному
        {
           // printf("Oh! A symbol!\n");
            if (c>=AP_L && c <=AP_R) /* а-я */
            {
                c-=AP_L;
                y[c]++;
                y[32]++;
                //printf("%f\n",y[c]);
            }
            if (c>=CAPS_L && c<= CAPS_R) /* А-Я */
            {
                y[32]++;
                c-=CAPS_L;
                y[c]++;
            //printf("%d\n", p[c]);
            }
            if (c==AP_JO || c==CAPS_JO)
            {
                y[32]++;//в общицй счетчик
                y[5]++;
            //printf("%d\n", p[c]);
            }
        }
        fclose (ff); // Когда прочитали все символы, закрываем файл

     /*расфасовываем массив, который на один файл*/
    m=y[0];//расфасовать согласно базовым данным
    y[0]=y[14];
    y[14]=y[19];
    y[19]=y[7];
    y[7]=y[16];
    y[16]=y[27];
    y[27]=y[22];
    y[22]=y[9];
    y[9]=y[11];
    y[11]=y[12];
    y[12]=y[4];
    y[4]=y[13];
    y[13]=y[15];
    y[15]=y[31];
    y[31]=y[26];
    y[26]=y[30];
    y[30]=y[20];
    y[20]=y[1];
    y[1]=y[5];
    y[5]=y[18];
    y[18]=y[3];
    y[3]=y[8];
    y[8]=y[2];
    y[2]=m;
        m=y[6];
    y[6]=y[17];
    y[17]=y[28];
    y[28]=y[25];
    y[25]=y[24];
    y[24]=m;
        m=y[21];
    y[21]=y[23];
    y[23]=m;
    for (i=0; i<=31; i++)
{
    csr[i]=0;
}
/*высчитвыаем среднее для кадой буквы*/
    float pp[33];
    int j;
    for (j=0;j<=31;j++)
    {
        pp[j]=p[j]/p[32];
        fprintf(qwero, "%f\n", pp[j]);
    }
    for (i=0; i<=31; i++)
    {
        if (y[i] !=0)
        {
         y[i]=y[i]/y[32];

        }
        //printf("avg: %f\n", y[i]);
    }
    /*среднее квадратичное для каждого файла*/
        for (i=0; i<=31; i++)
        {
            csr[i]=csr[i]+((y[i]-pp[i])*(y[i]-pp[i]));
            //printf("avg: %f\n", csr[i]);
        }
        for (i=0; i<=31; i++)
        {
            printf("j");
            //fprintf(qwero1, "f\n");
            csr[i]=csr[i]/n;
           // fprintf(qwero1, "%f\n", csr[i]);
        }
        for (i=0; i<=31; i++)
        {
            fprintf(qwero1, "%f\n", sqrt(csr[i]));
            fprintf(qwero1, "%f\n", n);
        }

    fprintf(qwero1,"\n");
    fprintf(qwero1, "\n");

            fclose(qwero1);
    } //2

}
//возврат на места
        m=p[0];
    p[0]=p[2];
    p[2]=p[8];
    p[8]=p[3];
    p[3]=p[18];
    p[18]=p[5];
    p[5]=p[1];
    p[1]=p[20];
    p[20]=p[30];
    p[30]=p[26];
    p[26]=p[31];
    p[31]=p[15];
    p[15]=p[13];
    p[13]=p[4];
    p[4]=p[12];
    p[12]=p[11];
    p[11]=p[9];
    p[9]=p[22];
    p[22]=p[27];
    p[27]=p[16];
    p[16]=p[7];
    p[7]=p[19];
    p[19]=p[14];
    p[14]=m;
        m=p[6];
        p[6]=p[24];
        p[24]=p[25];
        p[25]=p[28];
        p[28]=p[17];
        p[17]=m;
    m=p[21];
    p[21]=p[23];
    p[23]=m;
    //возврат на места
}


void main()
{
    float n=0;
    int i;
    for (i=0; i<=32; i++)
    {
        p[i]=(float)0;
    }
    if ((dir = opendir ("C:\\qwer")) == NULL) // Открываем директорию.
    {
        printf ("Error while opening directory"); //Если директория не нашлась, пишем сообщение об ошибке.
        return 1;
    }
    else //Если всё хорошо, идём дальше
    {
        while ((ent = readdir (dir)) != NULL) //Читаем следующее имя файла в директории. Оно будет равно NULL, если файлы закончиились.
        {
            n++;
        }
        closedir (dir); //Когда все файлы обработаны, закрываем директорию.
/*        printf ("Done!\n"); //Пишем что-нибудь на прощание.*/
    }
    n=n-2;

    if ((dir = opendir ("C:\\qwer")) == NULL) // Открываем директорию.
    {
        printf ("Error while opening directory"); //Если директория не нашлась, пишем сообщение об ошибке.
        return 1;
    }
    else //Если всё хорошо, идём дальше
    {
        while ((ent = readdir (dir)) != NULL) //Читаем следующее имя файла в директории. Оно будет равно NULL, если файлы закончиились.
        {
        /*  *ent).d_name или ent -> d_name это функция, которая возвращает строку, в которой записано имя файла.
            Эту строку мы передаём нашей функции, filework
        */
            filework ((*ent).d_name, n);
        }
        closedir (dir); //Когда все файлы обработаны, закрываем директорию.
/*        printf ("Done!\n"); //Пишем что-нибудь на прощание.*/
    }
}

